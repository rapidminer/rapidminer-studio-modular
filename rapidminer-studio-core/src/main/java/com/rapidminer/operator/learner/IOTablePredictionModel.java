/**
 * Copyright (C) 2001-2021 by RapidMiner and the contributors
 *
 * Complete list of developers available at our web site:
 *
 * http://rapidminer.com
 *
 * This program is free software: you can redistribute it and/or modify it under the terms of the GNU Affero General
 * Public License as published by the Free Software Foundation, either version 3 of the License, or (at your option) any
 * later version.
 *
 * This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied
 * warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU Affero General Public License for more
 * details.
 *
 * You should have received a copy of the GNU Affero General Public License along with this program. If not, see
 * http://www.gnu.org/licenses/.
 */
package com.rapidminer.operator.learner;

import java.util.Collections;
import java.util.Iterator;
import java.util.LinkedHashMap;
import java.util.List;
import java.util.Map;

import com.rapidminer.adaption.belt.IOTable;
import com.rapidminer.belt.buffer.Buffers;
import com.rapidminer.belt.buffer.NumericBuffer;
import com.rapidminer.belt.column.Column;
import com.rapidminer.belt.column.Dictionary;
import com.rapidminer.belt.table.Builders;
import com.rapidminer.belt.table.Table;
import com.rapidminer.belt.table.TableBuilder;
import com.rapidminer.belt.table.Tables;
import com.rapidminer.belt.util.ColumnReference;
import com.rapidminer.belt.util.ColumnRole;
import com.rapidminer.example.Attributes;
import com.rapidminer.operator.AbstractIOTableModel;
import com.rapidminer.operator.Operator;
import com.rapidminer.operator.OperatorException;
import com.rapidminer.tools.I18N;
import com.rapidminer.tools.belt.BeltErrorTools;
import com.rapidminer.tools.belt.BeltTools;


/**
 * The {@link IOTable} prediction model is the superclass for all objects generated by learners that work on tables,
 * i.e. it can be used to create a prediction for a given table. Analog of {@link PredictionModel} for tables.
 *
 * @author Gisa Meier
 * @since 9.10
 */
public abstract class IOTablePredictionModel extends AbstractIOTableModel {

	/**
	 * This parameter specifies the data types at which the model can be applied on in relation to the training data.
	 */
	private Tables.TypeRequirement[] typeRequirements;

	/**
	 * This parameter specifies the column set relation between data the model is applied to and the training data.
	 */
	private Tables.ColumnSetRequirement columnSetRequirement;

	/**
	 * Creates a new prediction model which is build based on the given {@link IOTable}. Please
	 * note that the given table is automatically stripped of its data which means that no reference to the data itself
	 * is kept but only to the header, i.e., to the types, dictionaries and column meta data.
	 *
	 * @param columnSetRequirement
	 *            describes the allowed relations between the given training table and future
	 *            tables on which this model will be applied. If this parameter is {@code null} no
	 *            error will be thrown.
	 * @param typeRequirements
	 *            describes the allowed relations between the types of the column set of the given
	 *            training table and the types of future columns of tables on which this model
	 *            will be applied. If this parameter is {@code null} no error will be thrown.
	 */
	protected IOTablePredictionModel(IOTable trainingTable, Tables.ColumnSetRequirement columnSetRequirement,
									 Tables.TypeRequirement... typeRequirements) {
		super(trainingTable);
		this.typeRequirements = typeRequirements;
		this.columnSetRequirement = columnSetRequirement;
	}

	/**
	 * Default constructor for json deserialization.
	 */
	protected IOTablePredictionModel() {
		super();
	}

	/**
	 * Creates the prediction column. In case of nominal prediction, the confidences are added to the confidences map.
	 * If the confidences are constructed via numeric buffers, the method {@link #createConfidenceBuffers(int)} can be
	 * used to construct them.
	 *
	 * @param adapted
	 * 		the regular columns of the input adapted to the training data
	 * @param confidences
	 * 		an empty map that confidences associated to nominal dictionary values can be added to
	 * @param operator
	 * 		the calling operator
	 * @return the prediction column
	 * @throws OperatorException
	 * 		if the prediction fails
	 */
	protected abstract Column performPrediction(Table adapted, Map<String, Column> confidences, Operator operator) throws OperatorException;

	@Override
	public IOTable apply(IOTable ioTable, Operator operator) throws OperatorException {
		Table original = ioTable.getTable();
		checkCompatibility(original, operator);
		Table adapted =
				Tables.adapt(BeltTools.regularSubtable(original), getTrainingHeader().getTable(),
						Tables.ColumnHandling.REORDER, Tables.DictionaryHandling.CHANGE);
		logWarnings(adapted);

		Table together = apply(adapted, original, operator);
		IOTable result = new IOTable(together);
		result.getAnnotations().addAll(ioTable.getAnnotations());
		return result;
	}

	@Override
	public boolean isModelKind(ModelKind modelKind) {
		return modelKind == ModelKind.SUPERVISED;
	}

	/**
	 * Applies the model to the adapted table and adds the result to the original table.
	 *
	 * @param adapted
	 * 		the original table adapted to the training data and without specials
	 * @param original
	 * 		the original input for applying the model
	 * @param operator
	 * 		the calling operator
	 * @return the original table plus additional columns from applying the model
	 * @throws OperatorException
	 * 		if the applying fails
	 */
	protected Table apply(Table adapted, Table original, Operator operator) throws OperatorException {
		Map<String, Column> confidences = new LinkedHashMap<>();
		Column predictedLabel = performPrediction(adapted, confidences, operator);

		TableBuilder builder = Builders.newTableBuilder(original);
		if (predictedLabel != null) {
			String predictionName = getPredictionName();
			if (builder.contains(predictionName)) {
				builder.remove(predictionName);
			}
			builder.add(predictionName, predictedLabel);
			builder.addMetaData(predictionName, ColumnRole.PREDICTION);
			for (Map.Entry<String, Column> entry : confidences.entrySet()) {
				String name = Attributes.CONFIDENCE_NAME + "(" + entry.getKey() + ")";
				if (builder.contains(name)) {
					builder.remove(name);
				}
				builder.add(name, entry.getValue());
				builder.addMetaData(name, ColumnRole.SCORE);
				builder.addMetaData(name, new ColumnReference(predictionName, entry.getKey()));
			}
		}
		return builder.build(BeltTools.getContext(operator));
	}

	/**
	 * Returns the name of the first column with role label or {@code null} if there is none.
	 *
	 * @return the name of the label column
	 */
	public String getLabelName() {
		List<String> labels = getTrainingHeader().getTable().select().withMetaData(ColumnRole.LABEL).labels();
		if (labels.isEmpty()) {
			return null;
		}
		return labels.get(0);
	}

	/**
	 * Returns the first column with role label or {@code null} if there is none.
	 *
	 * @return the label column
	 */
	protected Column getLabelColumn() {
		String labelName = getLabelName();
		return labelName == null ? null : getTrainingHeader().getTable().column(labelName);
	}

	/**
	 * Returns the prediction name associated with the label name.
	 *
	 * @return the derived prediction name.
	 */
	protected String getPredictionName() {
		String labelName = getLabelName();
		if (labelName == null) {
			return Attributes.PREDICTION_NAME;
		} else {
			return Attributes.PREDICTION_NAME + "(" + labelName + ")";
		}
	}

	/**
	 * Checks the compatibility of the table with the training header with respect to the type and column set
	 * requirements using {@link BeltErrorTools#requireCompatibleRegulars}.
	 *
	 * @param table
	 * 		the table to check
	 * @param operator
	 * 		the calling operator
	 * @throws OperatorException
	 * 		in case of incompatibilities
	 */
	protected void checkCompatibility(Table table, Operator operator) throws OperatorException {
		if (columnSetRequirement != null) {
			Tables.TypeRequirement[] dataTypeRequirements = this.typeRequirements;
			if (dataTypeRequirements == null) {
				dataTypeRequirements = new Tables.TypeRequirement[0];
			}
			BeltErrorTools.requireCompatibleRegulars(operator, table, getTrainingHeader().getTable(),
					columnSetRequirement, dataTypeRequirements);
		}
	}

	/**
	 * Checks if the adapted regulars match the training regulars and logs warnings if not.
	 *
	 * @param adapted
	 * 		the original table adapted to the training data and without specials
	 */
	protected void logWarnings(Table adapted) {
		Table regularTraining = BeltTools.regularSubtable(getTrainingHeader().getTable());
		// check number of columns
		checkColumns(adapted, regularTraining);

		// check if all training columns are part of the application table and have the same types and values
		for (int i = 0; i < regularTraining.width(); i++) {
			String name = regularTraining.label(i);
			Column trainingColumn = regularTraining.column(i);
			if (!adapted.contains(name)) {
				logWarning(I18N.getMessage(I18N.getLoggingBundle(),"com.rapidminer.operator.learner.PredictionModel.attribute_missing", name));
			} else {
				Column applicationColumn = adapted.column(name);
				if (trainingColumn.type().id() != applicationColumn.type().id()) {
					logWarning(I18N.getMessage(I18N.getLoggingBundle(),"com.rapidminer.operator.learner.PredictionModel.different_types",
							name, trainingColumn.type().id().toString(), applicationColumn.type().id().toString()));
				} else {
					// check nominal values
					checkNominalValues(name, trainingColumn, applicationColumn);
				}
			}
		}
	}

	/**
	 * Checks that the dictionaries of the two columns match and logs warning if not.
	 */
	private void checkNominalValues(String name, Column trainingColumn, Column applicationColumn) {
		if (trainingColumn.type().id() == Column.TypeId.NOMINAL) {
			if (trainingColumn.getDictionary().size() != applicationColumn.getDictionary().size()) {
				logWarning(I18N.getMessage(I18N.getLoggingBundle(),"com.rapidminer.operator.learner.PredictionModel.nominal_values",
						name, trainingColumn.getDictionary().size(), applicationColumn.getDictionary().size()));
			} else {
				if (!trainingColumn.getDictionary().equals(applicationColumn.getDictionary())) {
					logWarning(I18N.getMessage(I18N.getLoggingBundle(),"com.rapidminer.operator.learner.PredictionModel.nominal_mapping",
							name));
				}
			}
		}
	}

	/**
	 * Checks that the number and the order of columns in the tables match and logs warning if not.
	 */
	private void checkColumns(Table adapted, Table regularTraining) {
		if (adapted.width() != regularTraining.width()) {
			logWarning(I18N.getMessage(I18N.getLoggingBundle(),"com.rapidminer.operator.learner.PredictionModel.regular_size",
					regularTraining.width(), adapted.width()));
		} else {
			// check order of columns
			Iterator<String> trainingNames = regularTraining.labels().iterator();
			Iterator<String> applicationNames = adapted.labels().iterator();
			while (trainingNames.hasNext() && applicationNames.hasNext()) {
				if (!trainingNames.next().equals(applicationNames.next())) {
					logWarning(I18N.getMessage(I18N.getLoggingBundle(),"com.rapidminer.operator.learner.PredictionModel.regular_order"));
					break;
				}
			}
		}
	}

	/**
	 * Constructs an ordered map from dictionary values of the nominal label column to empty numeric buffers of the
	 * given height.
	 *
	 * @param height
	 * 		the height of the columns to construct
	 * @return a map of dictionary values to empty numeric buffers
	 */
	protected Map<String, NumericBuffer> createConfidenceBuffers(int height) {
		Column labelColumn = getLabelColumn();
		if (labelColumn.type().id() == Column.TypeId.NOMINAL) {
			LinkedHashMap<String, NumericBuffer> map = new LinkedHashMap<>();
			for (Dictionary.Entry entry : labelColumn.getDictionary()) {
				map.put(entry.getValue(), Buffers.realBuffer(height));
			}
			return map;
		} else {
			return Collections.emptyMap();
		}
	}

	@Override
	public String toString() {
		return getName() + " (prediction model for label " + getLabelName() + ")";
	}

}
